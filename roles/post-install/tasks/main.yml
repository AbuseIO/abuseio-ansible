---
- name: Install certbot apache plugin
  apt:
    name:
      - python3-certbot
      - python3-certbot-apache
    state: present

- name: Enable Apache headers
  command: a2enmod headers
  register: apache_headers
  changed_when: "'already enabled' not in (apache_headers.stdout | default('')) and 'already enabled' not in (apache_headers.stderr | default(''))"

- name: Enable Apache rewrite
  apache2_module:
    name: rewrite
    state: present
  register: apache_rewrite

- name: Enable Apache SSL
  apache2_module:
    name: ssl
    state: present

- name: Check if certificate already exists
  stat:
    path: "/etc/letsencrypt/live/{{ abuseio_hostname }}/fullchain.pem"
  register: cert

- name: Issue and install certificate with Certbot Apache plugin
  command: >
    certbot --apache --noninteractive --agree-tos
    --email admin@{{ abuseio_hostname }}
    --redirect -d {{ abuseio_hostname }}
  when: not cert.stat.exists

- name: Switch APP_URL to https in .env
  lineinfile:
    path: "{{ abuseio_home }}/.env"
    regexp: '^APP_URL='
    line: 'APP_URL=https://{{ abuseio_hostname }}'
    backrefs: no
  when: cert.stat.exists or (cert is changed)
  register: appurl_update

- name: Cache Laravel config after APP_URL change
  command: php artisan config:cache
  args:
    chdir: "{{ abuseio_home }}"
  when: cert.stat.exists or (cert is changed)
  become: yes
  become_user: "{{ abuseio_user }}"

- name: Reload Postfix to pick up TLS certificates
  service:
    name: postfix
    state: reloaded
  when: cert.stat.exists or (cert is changed)

- name: Restart Apache to apply TLS and APP_URL
  service:
    name: apache2
    state: restarted
  when: cert.stat.exists or (cert is changed) or (appurl_update is defined and appurl_update is changed) or (apache_rewrite is defined and apache_rewrite is changed) or (apache_headers is defined and apache_headers is changed)

- name: Change the root user password (optional, if you prefer password auth)
  community.mysql.mysql_user:
    name: root
    host: localhost
    password: "{{ mysql_root_password }}"
    login_unix_socket: /run/mysqld/mysqld.sock
  when: mysql_root_password is defined and (mysql_root_password | length) > 0

- name: Remove anonymous users
  community.mysql.mysql_user:
    name: ""
    host: "{{ item }}"
    state: absent
    login_user: root
    login_password: "{{ mysql_root_password }}"
    login_unix_socket: /run/mysqld/mysqld.sock
  loop:
    - localhost
    - "{{ ansible_hostname }}"
    - 127.0.0.1
    - ::1

- name: Disallow root login remotely (ensure root@'%' is absent)
  community.mysql.mysql_user:
    name: root
    host: "%"
    state: absent
    login_user: root
    login_password: "{{ mysql_root_password }}"
    login_unix_socket: /run/mysqld/mysqld.sock

- name: Remove the test database and its privileges
  community.mysql.mysql_db:
    name: test
    state: absent
    login_user: root
    login_password: "{{ mysql_root_password }}"
    login_unix_socket: /run/mysqld/mysqld.sock

- name: Ensure privilege tables are reloaded
  ansible.builtin.command: mysql --socket=/run/mysqld/mysqld.sock -e "FLUSH PRIVILEGES;"
  changed_when: true

- name: Obtain initial cert (standalone)
  command: >
    certbot certonly --noninteractive --agree-tos --email admin@{{ abuseio_hostname }}
    --standalone -d {{ abuseio_hostname }}
  when: false  # optional; you can run manually or rely on apache plugin later